## 函数

​	函数的声明以关键字**fun**开始，函数名称紧随其后,接下来是括号括起来的参数列表，参数列表的后面跟着返回类型，它们之间用一个冒号隔开。

	fun max(a:Int,b:Int):Int{
		return if(a > b) a else b  // 在kotlin中，if是有结果值的表达式
	}
	
	// max 函数名
	// a b 参数，参数类型在参数后面，以冒号分开。
	// 返回值在参数后面，同样以冒号分开
**语句和表达式**

​	在kotlin中，if是表达式，而不是语句。语句和表达式的区别在于，表达式有值，并且能作为另一个表达式的一部分使用。而语句总是包围着它的代码块中的顶层元素，并且没有自己的值。在java中，所有的控制结构都是语句，而在kotlin中，除了循环(**for,do,do/whine**)以外大多数控制结构都是表达式。

​	java中赋值操作是表达式，在kotlin中反而变成了语句。

**表达式函数体**

​	如果一个函数是由单个表达式构成的，可以用这个表达式作为完整的函数体，并去掉括号和return语句:

`fun max(a:Int,b:Int):Int = if(a > b) a else b`

​	为了进一步简化max函数，可以省掉返回类型:

`fun max(a:Int,b:Int) = if(a > b) a else b`

​	对表达式体函数来说，编译器会分析作为函数体的表达式，并把它的类型作为函数的返回类型，即使没有显示地写出来。这种分析通常被称为**类型推导**。



## 变量

**声明变量方式**

`val question = "hello"`

`val answer = 2`

`val answer:Int = 3`

`val age:Int?` **// Int?代表可控类型**

​	和表达式函数一样，如果你不指定变量的类型，编译器会分析初始化器表达式的值，并把它的类型作为变量的类型。

**可变变量和不可变变量**

​	val(来自value)：不可变引用。使用val声明的变量不能在初始化之后再次赋值。它对应的是Java的final变量。

​	var(来自variable)：可变引用。这种变量的值可以被改变。这种声明对应的是普通(非final)的Java变量。

​	**默认情况下，应该尽可能地使用val关键字来声明所有的kotlin变量，仅在必要的时候换成var。使用不可变引用，不可变对象及无副作用的函数让你的代码更接近函数式编程风格。**

​	使用var关键字允许变量改变自己的值，但它的类型却是改变不了的。

​	`var answer = 1  asnwer="1"//这样会报错`



## 扩展函数

​	扩展函数是一个类的成员函数，不过定义在类的外面。如果要是顶一个扩展函数，把要扩展的类或者接口的名称添加到该函数前，这个类的名称叫做**接收者类型**；用来调用这个扩展函数的对象，叫做接收者对象。接收者类型是由扩展函数定义的，接收者对象是该类型的一个实例。

`fun String.lastChar():Char = this.get(this.length - 1) // String为接收者类型 this为接收者对象`

  	**在扩展函数中，可以直接访问被扩展的类的其他方法和属性，就像是在这个类自己的方法中访问它们一样。**需要注意的是，扩展函数不能访问私有的或者受保护的成员，这和内部类定义的方法不同。‘

​	实质上，扩展函数就是静态函数，它把调用对象作为了它的第一个参数。另外一点，扩展函数不能被重写。如果一个类的成员函数和和扩展函数有相同的签名，那么优先使用成员函数，扩展函数将被覆盖。



## 处理集合：可变参数、中缀调用和库的支持

可变参数的关键字vararg，可以用来声明一个函数将可能有任意数量的参数。

一个中缀表示法，当你在调用一些只有一个次参数的函数时，使用它会让代码更简练。

解构声明，用来把一个单独的组合值展开到多个变量中。

`val map = mapOf(1 to "one",7 to "seven")`

上述代码中的to不是内置的解构，而是一种特殊的函数调用，被称为中缀调用。

在中缀调用中，没有添加额外的分隔符，函数名是直接放在目标对象名和参数之间的。中缀调用可以与只有一个参数的函数一起使用，无论是普通的函数还是扩展函数。要允许使用中缀调用函数，需要使用infix修饰符来标记它。

`infix fun Any.to(other:Any) = Pair(this,other)`

Pair是Kotlin标准库中的类，它表示一对元素。可以直接用Pair的内容来初始化两个变量:

`val (numbler,name) = 1 to "one"` **这个功能称为解构声明。**



## 局部函数和扩展

局部函数：在函数内部嵌套函数。嵌套函数也可以放到扩展函数中。

![局部函数](https://raw.githubusercontent.com/xiaofans/BlogSource/master/kotlin%E5%AD%A6%E4%B9%A0/pics/%E5%B1%80%E9%83%A8%E5%87%BD%E6%95%B0.png)

![局部函数与扩展函数相互使用](https://raw.githubusercontent.com/xiaofans/BlogSource/master/kotlin%E5%AD%A6%E4%B9%A0/pics/%E5%B1%80%E9%83%A8%E5%87%BD%E6%95%B0%E4%B8%8E%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0.png)