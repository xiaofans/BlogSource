## **字符串**

##### 1、不可变String

String对象是不可变的，String类的每一个看起来会修改String值的方法，实际上都是创建了一个全新的String对象，以包含修改后的字符串内容。而最初的String对象则丝毫未动。



## 类型信息

运行时类型信息使得你可以在程序运行时发现和使用类型信息。

Java在运行时识别对象和类的信息主要有两种方式，一种是传统的RTTI，它假定我们在编译时已经知道了所有的类型；另一种是反射机制，它允许我们在运行时发现和使用类的信息。

要理解RTTI在Java中的工作原理，首先必须知道类型信息在运行时是如何表示的。这项工作是由称为Class对象的特殊对象完成的，它包含了与类有关的信息。

类是程序的一部分，每个类都有一个Class对象。换言之，每当编写并且编译了一个新类，就会产生一个Class对象(更恰当的说，是被保存在一个同名的.class文件中)。为了生成这个类的对象，运行这个程序的Java虚拟机(JVM)将使用被称为“类加载器”的子系统。

类加载器的子系统实际上可以包含一条类加载器链，但是只有一个原生类加载器，它是JVM实现的一部分。原生加载器加载的所谓的可信类，包括Java API类，它们通常是从本地盘加载的。在这条链中，通常不需要添加额外的类加载器。

所有的类都是在对其第一次使用时，动态加载到JVM中的。当程序创建第一个类的静态成员的引用时，就会加载这个类。这个证明构造器也是类的静态方法，即使在构造器之前并没有使用static关键字。因此，使用new操作符创建类的新对象也会被当作对类的静态成员的引用。

因此，Java程序在它开始运行之前并非被完全加载。其各个部分是在必要时才加载的。

类加载器首先检查这个类的Class对象是否已经加载。如果尚未加载，默认的加载器就会根据类名查找.class文件。在这个类的字节码被加载时，它们会接受验证，以确保其没有被破坏，并且不包含不良java代码。

一旦某个类的Class对象被载入内存，它就被用来创建这个类的所有对象。

## 类字面常量

Java还提供了另外一种方法来生成对Class对象的引用，即使用类字面常量。

XX.class,这样简单，安全并且高效。

类字面常量可以应用于普通的类，接口，数组和基本数据类型。

使用.class创建对Class对象的引用的时候，不会自动的初始化该Class对象。为了使用类而做的准备工作实际包含三个步骤：

1.加载，这个是由类加载器执行的。该步骤将查找字节码，并从这些字节码中创建一个Class对象。

2.链接，在链接阶段将验证类中的字节码，为静态域分配存储空间，并且如果必须的话，将解析这个类创建的对其他类的所有引用。

3.初始化。如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块。初始化被延迟到了对静态方法（构造器隐式地是静态的）或者是非静态域进行首次引用时才执行。



## 反射:运行时的类信息

如果不知道某个对象的确切类型，RTTI可以告诉你。但是有一个限制：这个类型在编译时必须已知，这样才能使用RTTI识别，并做一些有用的事。换句话说，在编译时，编译器必须知道所有要通过RTTI来处理的类。

RTTI和反射的区别:对RTTI来说，编译器在编译时打开和检查.class文件。(换句话说，我们用普通方式调用对象的所有方法)，而对于反射机制来说，.class文件在编译时是不可获取的，所以在运行时打开和检查.class文件。



## 动态代理

代理是基本的设计模式之一，它是你为了提供额外的或不同的操作，而插入的用来替代“实际”对象的对象。这些操作通常设计与“实际”对象的通信，因此代理通常充当着中间人的角色。

作用:在任何时刻，只要你想要将额外的操作从“实际”对象中分离到不同的地方，特别是当你希望能够很容易地做出修改，从没有使用额外操作转为使用，或者反过来讲，代理就很有用。如果你希望跟踪RealObj的方法调用，希望度量这些调用的开销的时候，代理可以使得你可以很容易地添加或移除他们。

Java动态代理比代理的思想更向前迈进了一步，因为它可以动态地创建代理并动态地处理对所有代理方法的调用。

参考来源

http://blog.csdn.net/javazejian/article/details/70768369?utm_source=gold_browser_extension

